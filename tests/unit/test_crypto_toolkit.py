"""
Unit tests for encryption and cryptography toolkit.

Tests symmetric/asymmetric encryption, hashing, signatures, key management,
and certificate operations.
"""

import pytest
from pathlib import Path
import tempfile

from src.deia.crypto_toolkit import (
    Hasher, SymmetricCrypto, AsymmetricCrypto, DigitalSignature,
    KeyManager, CertificateManager, SecureRandomGenerator,
    HashAlgorithm, SymmetricAlgorithm, AsymmetricAlgorithm,
    EncryptionResult, KeyPair, encode_base64, decode_base64
)


# ===== FIXTURES =====

@pytest.fixture
def plaintext():
    """Test plaintext."""
    return "Hello, this is a secret message!"


@pytest.fixture
def password():
    """Test password."""
    return "SecurePassword123!"


@pytest.fixture
def encryption_key():
    """Test encryption key."""
    return SecureRandomGenerator.generate_bytes(32)  # 256-bit key


@pytest.fixture
def rsa_keypair():
    """Generate RSA keypair."""
    return AsymmetricCrypto.generate_rsa_keypair(2048)


@pytest.fixture
def ecc_keypair():
    """Generate ECC keypair."""
    return AsymmetricCrypto.generate_ecc_keypair("P256")


# ===== SECURE RANDOM GENERATION TESTS =====

class TestSecureRandomGenerator:
    """Test secure random generation."""

    def test_generate_bytes(self):
        """Test generating random bytes."""
        data = SecureRandomGenerator.generate_bytes(32)
        assert len(data) == 32
        assert isinstance(data, bytes)

    def test_generate_iv(self):
        """Test generating IV."""
        iv = SecureRandomGenerator.generate_iv()
        assert len(iv) == 16
        assert isinstance(iv, bytes)

    def test_generate_salt(self):
        """Test generating salt."""
        salt = SecureRandomGenerator.generate_salt()
        assert len(salt) == 16
        assert isinstance(salt, bytes)

    def test_generate_nonce(self):
        """Test generating nonce."""
        nonce = SecureRandomGenerator.generate_nonce()
        assert len(nonce) == 12
        assert isinstance(nonce, bytes)

    def test_randomness(self):
        """Test that generated bytes are random."""
        data1 = SecureRandomGenerator.generate_bytes(32)
        data2 = SecureRandomGenerator.generate_bytes(32)
        assert data1 != data2


# ===== HASHING TESTS =====

class TestHasher:
    """Test hashing functionality."""

    def test_hash_string_sha256(self, plaintext):
        """Test hashing string with SHA256."""
        hash_value = Hasher.hash(plaintext, HashAlgorithm.SHA256)
        assert isinstance(hash_value, str)
        assert len(hash_value) == 64  # SHA256 hex is 64 chars

    def test_hash_bytes_sha256(self, plaintext):
        """Test hashing bytes with SHA256."""
        hash_value = Hasher.hash(plaintext.encode(), HashAlgorithm.SHA256)
        assert isinstance(hash_value, str)
        assert len(hash_value) == 64

    def test_hash_consistency(self, plaintext):
        """Test that hashing same input produces same output."""
        hash1 = Hasher.hash(plaintext, HashAlgorithm.SHA256)
        hash2 = Hasher.hash(plaintext, HashAlgorithm.SHA256)
        assert hash1 == hash2

    def test_hash_sha384(self, plaintext):
        """Test SHA384 hashing."""
        hash_value = Hasher.hash(plaintext, HashAlgorithm.SHA384)
        assert len(hash_value) == 96  # SHA384 hex is 96 chars

    def test_hash_sha512(self, plaintext):
        """Test SHA512 hashing."""
        hash_value = Hasher.hash(plaintext, HashAlgorithm.SHA512)
        assert len(hash_value) == 128  # SHA512 hex is 128 chars

    def test_verify_hash(self, plaintext):
        """Test hash verification."""
        hash_value = Hasher.hash(plaintext)
        assert Hasher.verify_hash(plaintext, hash_value)

    def test_verify_hash_fails(self, plaintext):
        """Test hash verification fails for different data."""
        hash_value = Hasher.hash(plaintext)
        assert not Hasher.verify_hash("Different text", hash_value)


# ===== SYMMETRIC ENCRYPTION TESTS =====

class TestSymmetricCrypto:
    """Test symmetric encryption."""

    def test_derive_key(self, password):
        """Test key derivation."""
        salt = SecureRandomGenerator.generate_salt()
        key1 = SymmetricCrypto.derive_key(password, salt)
        assert len(key1) == 32  # Default 256-bit
        assert isinstance(key1, bytes)

    def test_derive_key_consistency(self, password):
        """Test key derivation is consistent."""
        salt = SecureRandomGenerator.generate_salt()
        key1 = SymmetricCrypto.derive_key(password, salt)
        key2 = SymmetricCrypto.derive_key(password, salt)
        assert key1 == key2

    def test_encrypt_decrypt_aes_cbc(self, plaintext, encryption_key):
        """Test AES CBC encryption/decryption."""
        encrypted = SymmetricCrypto.encrypt(
            plaintext,
            encryption_key,
            SymmetricAlgorithm.AES_256_CBC
        )
        assert encrypted.ciphertext != plaintext.encode()
        assert encrypted.iv is not None

        decrypted = SymmetricCrypto.decrypt(
            encrypted,
            encryption_key,
            SymmetricAlgorithm.AES_256_CBC
        )
        assert decrypted.decode() == plaintext

    def test_encrypt_decrypt_aes_gcm(self, plaintext, encryption_key):
        """Test AES GCM encryption/decryption."""
        encrypted = SymmetricCrypto.encrypt(
            plaintext,
            encryption_key,
            SymmetricAlgorithm.AES_256_GCM
        )
        assert encrypted.tag is not None

        decrypted = SymmetricCrypto.decrypt(
            encrypted,
            encryption_key,
            SymmetricAlgorithm.AES_256_GCM
        )
        assert decrypted.decode() == plaintext

    def test_encrypt_decrypt_chacha20(self, plaintext, encryption_key):
        """Test ChaCha20 encryption/decryption."""
        encrypted = SymmetricCrypto.encrypt(
            plaintext,
            encryption_key,
            SymmetricAlgorithm.CHACHA20
        )
        assert encrypted.ciphertext != plaintext.encode()

        decrypted = SymmetricCrypto.decrypt(
            encrypted,
            encryption_key,
            SymmetricAlgorithm.CHACHA20
        )
        assert decrypted.decode() == plaintext

    def test_different_iv_different_ciphertext(self, plaintext, encryption_key):
        """Test that same plaintext with different IVs produces different ciphertexts."""
        encrypted1 = SymmetricCrypto.encrypt(plaintext, encryption_key)
        encrypted2 = SymmetricCrypto.encrypt(plaintext, encryption_key)
        assert encrypted1.ciphertext != encrypted2.ciphertext


# ===== ASYMMETRIC ENCRYPTION TESTS =====

class TestAsymmetricCrypto:
    """Test asymmetric encryption."""

    def test_generate_rsa_keypair(self):
        """Test RSA keypair generation."""
        keypair = AsymmetricCrypto.generate_rsa_keypair(2048)
        assert keypair.private_key is not None
        assert keypair.public_key is not None
        assert keypair.algorithm == AsymmetricAlgorithm.RSA_2048

    def test_generate_ecc_keypair(self):
        """Test ECC keypair generation."""
        keypair = AsymmetricCrypto.generate_ecc_keypair("P256")
        assert keypair.private_key is not None
        assert keypair.public_key is not None
        assert keypair.algorithm == AsymmetricAlgorithm.ECDH_P256

    def test_encrypt_decrypt_rsa(self, plaintext, rsa_keypair):
        """Test RSA encryption/decryption."""
        ciphertext = AsymmetricCrypto.encrypt_rsa(plaintext, rsa_keypair.public_key)
        assert ciphertext != plaintext.encode()

        decrypted = AsymmetricCrypto.decrypt_rsa(ciphertext, rsa_keypair.private_key)
        assert decrypted.decode() == plaintext

    def test_rsa_encryption_unique(self, plaintext, rsa_keypair):
        """Test that RSA encryption is probabilistic (different each time)."""
        ciphertext1 = AsymmetricCrypto.encrypt_rsa(plaintext, rsa_keypair.public_key)
        ciphertext2 = AsymmetricCrypto.encrypt_rsa(plaintext, rsa_keypair.public_key)
        # RSA with OAEP padding is probabilistic
        assert ciphertext1 != ciphertext2


# ===== DIGITAL SIGNATURE TESTS =====

class TestDigitalSignature:
    """Test digital signature operations."""

    def test_sign_and_verify(self, plaintext, rsa_keypair):
        """Test signing and verifying."""
        signature = DigitalSignature.sign(plaintext, rsa_keypair.private_key)
        assert isinstance(signature, bytes)
        assert len(signature) > 0

        verified = DigitalSignature.verify(plaintext, signature, rsa_keypair.public_key)
        assert verified

    def test_signature_verification_fails(self, plaintext, rsa_keypair):
        """Test signature verification fails for modified data."""
        signature = DigitalSignature.sign(plaintext, rsa_keypair.private_key)

        modified = plaintext + " modified"
        verified = DigitalSignature.verify(modified, signature, rsa_keypair.public_key)
        assert not verified

    def test_different_keys_fail_verification(self, plaintext, rsa_keypair):
        """Test signature verification fails with different key."""
        signature = DigitalSignature.sign(plaintext, rsa_keypair.private_key)

        other_keypair = AsymmetricCrypto.generate_rsa_keypair(2048)
        verified = DigitalSignature.verify(plaintext, signature, other_keypair.public_key)
        assert not verified


# ===== KEY MANAGEMENT TESTS =====

class TestKeyManager:
    """Test key management."""

    def test_export_private_key(self, rsa_keypair):
        """Test exporting private key."""
        key_data = KeyManager.export_private_key(rsa_keypair.private_key)
        assert isinstance(key_data, bytes)
        assert b'-----BEGIN PRIVATE KEY-----' in key_data

    def test_export_public_key(self, rsa_keypair):
        """Test exporting public key."""
        key_data = KeyManager.export_public_key(rsa_keypair.public_key)
        assert isinstance(key_data, bytes)
        assert b'-----BEGIN PUBLIC KEY-----' in key_data

    def test_load_private_key(self, rsa_keypair):
        """Test loading private key."""
        exported = KeyManager.export_private_key(rsa_keypair.private_key)
        loaded = KeyManager.load_private_key(exported)
        assert loaded is not None

    def test_load_public_key(self, rsa_keypair):
        """Test loading public key."""
        exported = KeyManager.export_public_key(rsa_keypair.public_key)
        loaded = KeyManager.load_public_key(exported)
        assert loaded is not None

    def test_save_and_load_key_from_file(self, rsa_keypair):
        """Test saving and loading key from file."""
        with tempfile.TemporaryDirectory() as tmpdir:
            key_path = Path(tmpdir) / "private_key.pem"
            key_data = KeyManager.export_private_key(rsa_keypair.private_key)
            KeyManager.save_key_to_file(key_data, key_path)

            assert key_path.exists()

            loaded = KeyManager.load_key_from_file(key_path)
            assert loaded is not None


# ===== CERTIFICATE TESTS =====

class TestCertificateManager:
    """Test certificate operations."""

    def test_generate_self_signed_cert(self, rsa_keypair):
        """Test generating self-signed certificate."""
        cert = CertificateManager.generate_self_signed_cert(
            rsa_keypair.private_key,
            "example.com"
        )
        assert cert.certificate is not None
        assert cert.subject == "C=US,ST=State,L=City,O=Organization,CN=example.com"

    def test_export_certificate(self, rsa_keypair):
        """Test exporting certificate."""
        cert = CertificateManager.generate_self_signed_cert(
            rsa_keypair.private_key,
            "example.com"
        )
        cert_data = CertificateManager.export_certificate(cert)
        assert isinstance(cert_data, bytes)
        assert b'-----BEGIN CERTIFICATE-----' in cert_data

    def test_load_certificate(self, rsa_keypair):
        """Test loading certificate."""
        cert = CertificateManager.generate_self_signed_cert(
            rsa_keypair.private_key,
            "example.com"
        )
        cert_data = CertificateManager.export_certificate(cert)

        loaded = CertificateManager.load_certificate(cert_data)
        assert loaded.certificate is not None


# ===== UTILITY TESTS =====

class TestUtilities:
    """Test utility functions."""

    def test_encode_decode_base64(self):
        """Test base64 encoding/decoding."""
        original = b"Hello, World!"
        encoded = encode_base64(original)
        decoded = decode_base64(encoded)
        assert decoded == original


# ===== INTEGRATION TESTS =====

class TestIntegration:
    """Integration tests for crypto toolkit."""

    def test_full_encryption_workflow(self, password):
        """Test full encryption workflow with key derivation."""
        plaintext = "Confidential data"
        salt = SecureRandomGenerator.generate_salt()
        key = SymmetricCrypto.derive_key(password, salt)

        # Encrypt
        encrypted = SymmetricCrypto.encrypt(plaintext, key)
        assert encrypted.ciphertext != plaintext.encode()

        # Decrypt
        decrypted = SymmetricCrypto.decrypt(encrypted, key)
        assert decrypted.decode() == plaintext

    def test_signature_and_hash(self, plaintext, rsa_keypair):
        """Test combining signatures and hashing."""
        # Hash the plaintext
        hash_value = Hasher.hash(plaintext)

        # Sign the hash
        signature = DigitalSignature.sign(hash_value, rsa_keypair.private_key)

        # Verify hash and signature
        assert Hasher.verify_hash(plaintext, hash_value)
        assert DigitalSignature.verify(hash_value, signature, rsa_keypair.public_key)

    def test_secure_file_transfer_simulation(self):
        """Simulate secure file transfer with encryption and signature."""
        # Generate keys
        keypair = AsymmetricCrypto.generate_rsa_keypair(2048)

        # Message
        message = "Important file contents"

        # Sign the message
        signature = DigitalSignature.sign(message, keypair.private_key)

        # Verify the message
        assert DigitalSignature.verify(message, signature, keypair.public_key)

        # Also hash it
        message_hash = Hasher.hash(message)
        assert Hasher.verify_hash(message, message_hash)
